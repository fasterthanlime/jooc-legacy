<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY version "v0.2 ninja">
<!ENTITY license SYSTEM "fdl.xml">
]>
<!-- 
Follow the white rabbit.
-->
<book>
  <bookinfo>
    <title>ooc &version; Language Reference</title>

    <author>
      <firstname>Amos</firstname>

      <surname>Wenger</surname>
    </author>

    <copyright>
      <year>2009</year>

      <holder>Amos Wenger</holder>
    </copyright>

    <date>2009-06-25</date>

    <legalnotice>
      <para>Distributed under the terms of the <link linkend="fdl" os="">GNU
      Free Documentation License v1.3</link></para>
    </legalnotice>

    <abstract>
      <para>This is the reference language manual for ooc &version;. It should
      be used as a reliable reference for implementation and dispute about the
      use of the ooc programming language.</para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <para>This book is adressed to several kinds of person:</para>

    <itemizedlist>
      <listitem>
        <para>Users, who wish to quickly grasp how things are done in
        ooc</para>
      </listitem>

      <listitem>
        <para>Compiler writers, who want to know what they should
        implement!</para>
      </listitem>

      <listitem>
        <para>Critics, who like to read, emit judgement, and do nothing about
        it</para>
      </listitem>
    </itemizedlist>

    <para>It is assumed, throughout the book, that you have a basic knowledge
    of programming. If you come from a C or Java programming background, you
    should feel at home.</para>

    <para>I hope you'll enjoy the read!</para>
  </preface>

  <chapter>
    <title>Variables</title>

    <section>
      <title>Types</title>

      <section>
        <title>Syntax</title>

        <para>All types should be in <literal>CamelCase</literal>, all
        variables and functions in <literal>camelCase</literal>. It is a
        significant difference from C and Java, for example. In ooc, an
        integer is declared as <literal>Int</literal>, a boolean as
        <literal>Bool</literal>, and so on.</para>

        <para>The justification for that is consistency. In Java, for example,
        primitive types are in lowercase (<literal>int</literal>,
        <literal>byte</literal>, <literal>short</literal>) and classes are in
        <literal>CamelCase</literal> (<literal>String</literal>,
        <literal>System</literal>). There is some kind of consistency in this
        model, ie. you clearly see what is low-level and high-level. However,
        ooc takes another approach of consistency. Implementation details
        shouldn't interfere with the formatting of the source code. Hence, no
        distinction is made between an <literal>Int</literal> and e.g. a
        <literal>MyClass</literal>, from a user point of view.</para>
      </section>

      <section>
        <title>Constants</title>

        <para>Constants are declared with the const keyword:</para>

        <programlisting>const Float EPSILON = 0.00001f;</programlisting>

        <para>Constants are usually implemented with
        <literal>#define</literal>s<footnote>
            <para>This may raise a concern: what about name collision? In
            practice, this is almost never a problem with ooc. The generated C
            code is always prefixed with a few underscores '_' and the package
            and source unit name. E.g. __my_app_MyUnit_CONSTANT</para>
          </footnote>, so it's really impossible to modify one.</para>
      </section>

      <section>
        <title>Types from C</title>

        <section>
          <title>Correspondance with C and Java types</title>

          <table>
            <title>Correspondance tables of types in C, Java, and ooc.</title>

            <tgroup cols="4">
              <thead>
                <row>
                  <entry>C</entry>

                  <entry>Java</entry>

                  <entry>ooc</entry>

                  <entry>Comment</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-</entry>

                  <entry>-</entry>

                  <entry>This</entry>

                  <entry>in a class definition, refers to the current class.
                  Really, really useful to avoid repetition.</entry>
                </row>

                <row>
                  <entry>void*</entry>

                  <entry>Object</entry>

                  <entry>Object</entry>

                  <entry>really just to get rid of the nasty pointer notation.
                  useful while waiting for generics</entry>
                </row>

                <row>
                  <entry>int</entry>

                  <entry>int</entry>

                  <entry>Int</entry>

                  <entry>often the best choice for storing numbers. use Bool
                  to store boolean values.</entry>
                </row>

                <row>
                  <entry>short</entry>

                  <entry>short</entry>

                  <entry>Short</entry>

                  <entry>of little use, really. use it when you have *huge*
                  arrays of numbers and tight memory.</entry>
                </row>

                <row>
                  <entry>char</entry>

                  <entry>char (UTF-16)</entry>

                  <entry>Char</entry>

                  <entry>use it only to store characters. for 8bit numbers,
                  see Octet</entry>
                </row>

                <row>
                  <entry>char*</entry>

                  <entry>String (class)</entry>

                  <entry>String</entry>

                  <entry>fully C-string compatible, unlike C++
                  strings.</entry>
                </row>

                <row>
                  <entry>unsigned char, uint8_t</entry>

                  <entry>byte</entry>

                  <entry>Octet</entry>

                  <entry>again, of little use. may be useful for storing e.g.
                  r, g, b components of a color</entry>
                </row>

                <row>
                  <entry>unsigned int</entry>

                  <entry>-</entry>

                  <entry>UInt</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>float</entry>

                  <entry>float</entry>

                  <entry>Float</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>double</entry>

                  <entry>-</entry>

                  <entry>Double</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long double</entry>

                  <entry>-</entry>

                  <entry>LDouble</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>long</entry>

                  <entry>long</entry>

                  <entry>Long</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long long</entry>

                  <entry>-</entry>

                  <entry>LLong</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>bool</entry>

                  <entry>boolean</entry>

                  <entry>Bool</entry>

                  <entry>uses stdbool's typedefs. You should use
                  <literal>true</literal> and <literal>false</literal> for
                  boolean literals, not 0 and 1.</entry>
                </row>

                <row>
                  <entry>pointer to function</entry>

                  <entry>hahahaha.</entry>

                  <entry>Func</entry>

                  <entry>really points to a function with no arguments
                  returning Int. more function pointer safety should be
                  introduced with generics.</entry>
                </row>

                <row>
                  <entry>size_t</entry>

                  <entry>-</entry>

                  <entry>Size</entry>

                  <entry>the type returned by sizeof. according to the C
                  standard, it should be used to store the 'size' of things,
                  e.g. byte count for memory-related functions (memcpy,
                  memmove)</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section>
          <title>Typedef (aliasing name types)</title>

          <para>Typedefs exist in ooc too. They're used as in C.</para>

          <programlisting>// This example is stupid, because it redefines the String type. It's just to show how typedefs are used.
typedef Char* String;

func main {

  String name = "princesse de slougadij";
  printf("A moins que vous n'epousiez la %s?\n", name);

}</programlisting>

          <para>Don't do funky stuff with typedef: it won't work. E.g.
          <literal>typedef struct { /* etc. */ };</literal> If want a data
          structure, <link linkend="classes">define a class</link>.</para>
        </section>

        <section>
          <title>Capitalization</title>

          <para>If you try to declare something as 'int i', you'll be greeted
          by the compiler with the error message 'Invalid type name int. Types
          must start with an upper-case letter'. In this case, you can sort it
          out by using the ooc-ish 'Int'. But sometimes you just can't, e.g.
          with GLib types, '<literal>gint</literal>',
          '<literal>guint</literal>', etc. The correct handling of these cases
          is to <literal>typedef</literal>' them to something
          capitalized.</para>

          <programlisting>include glib;

typedef guint GUInt;

func main {

  GUInt myPlatformSafeInt = 69;
  gprintf("Now GLib and the ooc compilers are happy.%d\n", myPlatformSafeInt);

}</programlisting>
        </section>

        <section>
          <title>Types that can't be resolved</title>

          <para>Although the C header parser embedded in the ooc compiler
          really tries its best, sometimes (especially with
          <literal>#define</literal>s all over the place), C types aren't
          recognized, and you have compile errors. This can be solved with the
          use of the <literal>ctype</literal> keyword.</para>
        </section>

        <section>
          <title>The 'This' special type.</title>

          <para>In the Java language as in ooc, you have the
          <literal>this</literal> keyword, to refer to the current instance of
          the object we're defining a function of, e.g.:</para>

          <programlisting>class Color {

  Float r, g, b;

  func compare(Float r) {
    if(r != this.r) {
      printf("different !\n");
    }
  }

}</programlisting>

          <para>ooc extends this concept and introduce the
          <literal>This</literal> type, which refers to the type of the class
          we're defining:</para>
        </section>
      </section>

      <section>
        <title>Covers</title>

        <para>A cover is a set of functions added to a primitive type. For
        example, String is a typedef to char*, and it has a cover
        (<literal>lang.String</literal>), which adds functions
        <literal>length</literal>, <literal>equals</literal>,
        <literal>startsWith</literal>, etc. Covers are low-level constructs
        with a high-level syntax, which makes them very useful in
        performance-critical environments.</para>

        <programlisting>include stdio;

typedef Char* String;

cover String {

  func print {
    puts(this);
  }

}

func main {

  String s = "Hello world!";
  s.print;

}
</programlisting>

        <para>Difference between class and covers will be treated more in
        depth in <link linkend="classes">a next chapter</link>.</para>
      </section>
    </section>

    <section>
      <title>Arrays</title>

      <section>
        <title>Raw C arrays</title>

        <para>Raw C arrays are declared almost as in C, expect the square
        brackets [] are placed somewhere meaningful</para>

        <programlisting>Char[] letters = malloc(26, sizeof(Int));
letter[0] = 'a';

Bool[256] keymap;
Bool escapePressed = keymap[27];

String[] greetings = {"Heya!", "Bien l'bonjour!", "Hallo =)"};

// actually taken from examples/gtk-tests/opengl.ooc
Int[] flags = {
  GDK_GL_RGBA,
  GDK_GL_RED_SIZE, 1,
  GDK_GL_GREEN_SIZE, 1,
  GDK_GL_BLUE_SIZE, 1,
  GDK_GL_DOUBLEBUFFER,
  GDK_GL_NONE,
}</programlisting>

        <para>This kind of arrays are exactly as fast and as unsafe as in C.In
        case you want higher-level arrays, you can wrap them in the Array
        class.</para>
      </section>

      <section>
        <title>The Array class</title>

        <para>The Array class does bound-checking, and allows you to use
        foreach through the array. All those features (classes, foreach) are
        discussed in the next chapters. Here are a few examples of uses of the
        Array class:</para>

        <programlisting>import structs.Array;

func main(Int argc, String[] argv) {

  for(Int arg: new Array(argc, argv)) {
    printf("Got arg '%s'\n", arg);
  }

  Array strings = new Array(4);
  strings.set(0, "Hai furry world!\n"); // okay, 0 &gt;= 0 and 0 &lt; 4
  strings.get(9); // ERROR! index out of bounds (9 &gt; 4).

}</programlisting>

        <para>Array is a fixed-size type. To store a variable number of
        elements, see the <literal>ArrayList</literal> and
        <literal>SparseList</literal> classes.</para>
      </section>
    </section>

    <section>
      <title>Pointers</title>

      <para>Pointers are used in ooc exactly as in C, although they are not as
      welcome. They're used extensively behind the scenes, to implement
      classes, etc, but their use is discouraged when not necessary. A good
      use case for using pointers (instead of a objects, for example) is
      low-level implementation of a speed-critical algorithm. Using pointers
      is to ooc what assembler is to C: something you shouldn't use unless you
      really need it for speed.</para>
    </section>
  </chapter>

  <chapter>
    <title>Functions</title>

    <section>
      <title>Definition</title>

      <section>
        <title>Syntax</title>

        <para>A function is declared with the
        <literal><literal>func</literal></literal> keyword.</para>

        <programlisting>// Empty function with no args that returns nothing
func useless;

func sayHello {
  printf("Hay, world!\n");
}

func saySomethingElse(String message) {
  printf("Dummy says: %s\n", message);
}

func add(Int arg1, Int arg2) -&gt; Int {
  return arg1 + arg2;
}
</programlisting>
      </section>

      <section>
        <title>Same name, different arguments</title>

        <para>In ooc, it's possible to have several functions with the same
        name and different arguments. Which function to call is selected at
        compilation time, based on the number of arguments and their
        types.</para>

        <programlisting>func main {
  dance();
  dance("Too much of heaven/Can bring you underground");
}

func dance {
  dance("Music's got me feeling so free/Celebrate and dance so free/One more time");
}

func dance(String lyrics) {
  printf("DANCE TO THE BEAT! Sing: %s\b", lyrics);
}</programlisting>
      </section>

      <section>
        <title>The main function: entry point</title>

        <para>In ooc, the main function is automatically specified to have the
        return type 'Int'. You can declare it either without arguments, or
        with argc, argv, and envp arguments (optional).</para>

        <programlisting>import structs.Array;

/** envp is optional! it contains the environment variables, and is null-terminated */
func main(Int argc, String[] argv, String[] envp) {

  for(String arg: new Array(argc, argv)) {
    printf("Got argument %s\n", arg);
  }

  Array envs = Array.nullTerminated(envp);
  for(String env: envs) {
    printf("Got environment variable %s\n", env);
  }

}</programlisting>
      </section>
    </section>

    <section>
      <title>Calling functions</title>

      <para>Functions can be called with or without parenthesis, if the
      function has no arguments. Depending on the cases, it can be more
      readable to have explicit parenthesis, or more practical to not have
      them. <emphasis role="bold">Be warned, though, calling functions without
      parenthesis only work with functions written in ooc. It won't work with
      included C functions, because the headers files are not parsed for
      function declarations.</emphasis><footnote>
          <para>The reason for that is simple. Parsing C headers is a
          nightmare. It's already done for typedefs, for example, and there
          are still cases where it fails (e.g. SDL headers). Portable header
          files are usually filled with #defines, and it makes the ooc parser
          have a hard job understanding them. To fix that, we'd have to
          complete the ooc included C preprocessor, which would be very time
          consuming. For now, you can work around the 'unrecognized types'
          issue with the 'ctype' keyword.</para>
        </footnote><programlisting>/*
 * In this example, we use SDL functions to demonstrate that
 * you have to use parenthesis to call C functions.
 * If you were to use the SDL in a real project, it'd be better to use the SDL bindings
 */
include SDL/SDL;

func main {
  init; // Need no parenthesis !
  quit;
}

func init {
  SDL_Init(SDL_INIT_EVERYTHING);
}

func quit {
  SDL_Quit(); // We must use parenthesis, cause it's a C function
}</programlisting></para>

      <para>Calling functions without parenthesis is particularly convenient
      with getters/setters, as we will see later on.</para>
    </section>

    <section>
      <title>Callbacks and pointers</title>

      <section>
        <title>Simple case</title>

        <para>In ooc, functions are almost-first-class-citizens. You can pass
        pointer to functions around easily:</para>

        <programlisting>func main {

  call(@kotokoSpeak);

}

func kotokoSpeak {

  printf("We have a very big problem!\n");

}

func call(Func toCall) {

  toCall();

}</programlisting>

        <para>Since mentioning a function's name without parenthesis is enough
        to call it, the '<literal>@</literal>' prefix is added before the
        function name to indicate that we want a pointer to it, not to execute
        it. This distinction is justified if you consider that a function
        could itself return a pointer to function, thus you can't let the
        compiler guess whether or not to call the function.</para>

        <para>'<literal>@</literal>' doesn't work the same as
        '<literal>&amp;</literal>' in C. For example, the Gtk class as a
        function mainQuit, and it's a common idiom in a gtk program to
        do:</para>

        <programlisting>window.connectNaked("destroy", Gtk.@mainQuit);</programlisting>

        <para>This ensures that Gtk.mainQuit() is called when the window is
        destroyed.</para>
      </section>

      <section>
        <title>Pointer to member functions</title>

        <para>This case is treated in <link linkend="classes">this
        chapter</link>.</para>
      </section>
    </section>

    <section>
      <title>Covers</title>

      <para>A cover is a set of functions added to a primitive type. As an
      example, is here a sample of the <literal>lang.String</literal> cover
      (included in the sdk of the standard ooc distribution):</para>

      <programlisting>typedef Char* String;

cover String {

  func length -&gt; Int {
    return strlen(this);
  }

}</programlisting>

      <para>The definition of String as presented above allows code
      like:</para>

      <programlisting>String word = "anticonstitutionnellement";
printf("the longest french word is %d chars long.\n", word.length);</programlisting>

      <para>Covers can't have constructors, thus they can't be
      instantiated.</para>
    </section>
  </chapter>

  <chapter id="classes">
    <title>Classes</title>

    <section>
      <title>Syntax</title>

      <section>
        <title>Definition</title>

        <para>Classes have member variables and member functions.</para>

        <programlisting>class Dog {

  String name;
  Int age;

  func new; // Empty constructor

  func woof {
    printf("Woof, woof!\n");
  }

}</programlisting>
      </section>

      <section>
        <title>Instanciation</title>

        <para>You can instanciate objects with the new keyword, access their
        member variables and call their member functions pretty much as in
        Java.</para>

        <programlisting>Dog dog = new Dog();</programlisting>

        <para>As with functions, you can instanciate empty constructors
        without parenthesis:</para>

        <programlisting>Dog dog = new Dog;</programlisting>

        <para>The compiler is even smart enough to figure which type to
        instanciate, after a variable declaration or a variable
        assignment:</para>

        <programlisting>Dog dog = new;
Cat cat;
cat = new("meow");</programlisting>

        <para>Not, that, unlike C++, declaring only:</para>

        <programlisting>Bird bird;</programlisting>

        <para>will make bird a dangling pointer. Every object is in fact a
        pointer to a structure. For more details about the underlying
        implementation, see <link linkend="abi">the ABI
        appendix</link>.</para>
      </section>

      <section>
        <title>Static fields</title>

        <para>There can be instance fields and static fields in a class, in
        the Java sense of these words. Example:</para>
      </section>

      <section>
        <title>Inheritance</title>

        <para>For now, ooc has a simple inheritance model, somewhat like Java.
        To inherit a class, use the <literal>from</literal> keyword. To
        override a function, use the <literal>override</literal> keyword, or
        define a function with the same signature. <literal>override</literal>
        has the advantage of change checking: if the signature of the
        implemented function changes, it'll yield a compile error, instead of
        compiling the wrong version silently (it has the same use as the
        <literal>@Override</literal> annotation in Java).</para>

        <programlisting>class Wheel {

  func roll {
    printf("Quelque-chose ne tourne pas rond.\n");
  }

}

class BetterWheel from Wheel {

  override roll {
    printf("Pierre qui roule n'amasse pas mousse\n");
  }

}

func main {

  Wheel w = new;
  w.roll; // prints "Quelque-chose", etc.

  BetterWheel bw = new;
  bw.roll; // prints "Pierre qui roule", etc.

  Wheel w2 = (Wheel) bw; // cast as in C/Java
  w2.roll; // prints "Pierre qui roule", etc.

}</programlisting>
      </section>

      <section>
        <title>Abstract class and functions</title>

        <para>You can declare classes as abstract. They can no longer
        instanciated, and serve as base classes for other. In abstract
        classes, you can define abstract functions, that must be implemented
        by concrete (=non-abstract) child classes. To implement an abstract
        function, use the <literal>implement</literal> keyword. It has the
        same advantage as the <literal>override</literal> keyword.</para>

        <programlisting>import structs.Array;

abstract class Singer {

  abstract func sing;

}

class Hives from Singer {

  implement sing {
    printf("Tick tick tick BOOM!\n");
  }

}

class Spiderbait from Singer {

  implement sing {
    printf("Tonight, I'm going outta my head!\n");
  }

}

func main {

  ArrayList singers = new;
  singers.add(new Hives);
  singers.add(new Spiderbait);

  for(Singer singer: singers) {
    singer.sing;
  }

}</programlisting>
      </section>

      <section>
        <title>Reflection</title>

        <para>ooc has limited support for reflection. For now, it's more of a
        proof of concept, but you can do:</para>

        <programlisting>import structs.Array;

func main {

  printType(new Array);

}

func printType(Object o) {

  printf("We got an object of type %s\n", o.class.name);

}</programlisting>

        <para>In the future, reflection should be completed with fields and
        functions listing, etc.</para>
      </section>

      <section>
        <title>Pointers to member functions</title>

        <para>Interesting subject, if any. For now, there is a simple
        workaround, which, unfortunately, is only useful if you have only one
        instance of the considered class at run time. It works like
        this</para>

        <programlisting>// declared somewhere
func registerCallback(Func func);

class Handler {

  static This instance;

}</programlisting>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Statements</title>

    <section>
      <title>loops</title>

      <section>
        <title>classic for</title>

        <para>As can be seen in C99 and Java:</para>

        <programlisting>for(Int i = 0; i &lt; max; i++) {
  // do stuff.
}

// or, more generally:

for(initialization; condition; iteration) {
  // body
}</programlisting>

        <para>Declaration of variables inside the for loop is authorized,
        since ooc is translated to C99.</para>
      </section>

      <section>
        <title>for in ranges</title>

        <section>
          <title>regular</title>

          <para>Somehow reminiscent of scripting languages:</para>

          <programlisting>for(Int i: 0..max) {
  // i goes from 0 to max excluded.
}

// real-world use case
func main(Int argc, String[] argv) {
  
  for(Int i: 1..argc) {
    printf("Got argument '%s'\n", argv[i]);
  }

}</programlisting>
        </section>

        <section>
          <title>reverse</title>

          <para>For terrorist geeks:</para>

          <programlisting>for(Int i: reverse 0..11) {
  printf("%d...\n", i);
}
printf("segmentation fault\n");</programlisting>
        </section>

        <section>
          <title>sparse</title>

          <para>You can specify the stepping</para>

          <programlisting>for(Int i: 2..100, 2) {
  printf("%d, ", i);
}
printf("are multiples of two from 0 to 100.");</programlisting>
        </section>
      </section>

      <section>
        <title>foreach</title>

        <para>Syntax vastly inspired by Java:</para>

        <programlisting>func printAll(List list) {

  for(String str: list) {
    printf("%s, ", str);
  }
  putc('\n');

}

// better than for in ranges
func main(Int argc, String[] argv) {

  for(String arg: new Array(argc, argv)) {
    printf("Got argument '%s'\n", arg);
  }

}</programlisting>
      </section>

      <section>
        <title>while</title>

        <para>As boring as the C/Java one:</para>

        <programlisting>Float x;
while(x &lt; 42.0f) {
  x += (x * x) / 69.0f;
}</programlisting>
      </section>
    </section>

    <section>
      <title>conditionals</title>

      <section>
        <title>if, else</title>

        <para>No surprises:</para>

        <programlisting>if(happy) {
  rejoice;
} else if(moody) {
  listenToMusic;
} else {
  cry;
}</programlisting>
      </section>

      <section>
        <title>switch, case</title>

        <para>No surprises either:</para>

        <programlisting>switch(action) {
  case DIE: die(); break;
  case MOVE: move(); break;
  case LEAVE: leave(); break;
  default: pray();
}</programlisting>
      </section>
    </section>

    <section>
      <title>flow control</title>

      <section>
        <title>break, continue</title>

        <para>Same use as in C/Java:</para>

        <programlisting>while(true) {
  if(shouldExit) {
    break;
  }
}

for(Int i: 0..max) {
  if(shouldSkip) {
    continue;
  }
}</programlisting>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Packages, headers, libraries</title>

    <para>ooc doesn't share C++'s affection for C-style headers. Source files,
    (called 'units'), are organized into folders (called 'packages'), much
    like Java packages without the hassle.</para>

    <section>
      <title>ooc packages</title>

      <para>There is no <literal>package</literal> keyword. The package of a
      source unit is relative to the sourcepath. You can import units from
      packages with the <literal>import</literal> keyword. For example, let's
      say we have a Talker unit:</para>

      <programlisting>class Talker {

  static func say(String message) {
    
  }

}</programlisting>
    </section>
  </chapter>

  <appendix id="abi">
    <title>ABI (Application Binary Interface)</title>

    <para>The ooc ABI is designed to be simple and straight-forward. Also,
    there is an official ABI so that different implementations be
    compatible.<footnote>
        <para>When I write <emphasis>different implementations</emphasis>, I
        particularly think about <ulink
        url="http://github.com/amoswenger/rock">rock, the all-new attempt to
        write an ooc compiler in the ooc language</ulink>. At the time of this
        writing, it's very young: time has been spent developing ooc's
        features that could be useful for rock, rather than rock itself. As
        always, contributors are very welcome!</para>
      </footnote></para>

    <para>Note that the ooc specification is still under heavy development, so
    it means that the ABI can change significantly from a "dot version" to
    another.</para>
  </appendix>

  <appendix id="fdl">
    &license;
  </appendix>

  <appendix>
    <title>Links</title>

    <para><ulink url="http://ooc-lang.org/">the official ooc
    website</ulink></para>

    <para><ulink url="http://github.com/amoswenger/ooc">the source git
    repository on GitHub</ulink></para>

    <para><ulink url="http://live.gnome.org/Vala">the Vala programming
    language: same spirit but tied on GLib (excellent for gtk/gnome
    apps)</ulink></para>
  </appendix>
</book>
