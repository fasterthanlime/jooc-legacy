<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY version "v0.2 ninja">
<!ENTITY license SYSTEM "fdl.xml">
]>
<!-- 
Follow the white rabbit.
-->
<book>
  <bookinfo>
    <title>ooc &version; Language Reference</title>

    <author>
      <firstname>Amos</firstname>

      <surname>Wenger</surname>
    </author>

    <copyright>
      <year>2009</year>

      <holder>Amos Wenger</holder>
    </copyright>

    <date>2009-06-25</date>

    <legalnotice>
      <para>Distributed under the terms of the <link linkend="fdl" os="">GNU
      Free Documentation License v1.3</link></para>
    </legalnotice>

    <abstract>
      <para>This is the reference language manual for ooc &version;. It should
      be used as a reliable reference for implementation and dispute about the
      use of the ooc programming language.</para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <para>This book is adressed to several kinds of person:</para>

    <itemizedlist>
      <listitem>
        <para>Users, who wish to quickly grasp how things are done in
        ooc</para>
      </listitem>

      <listitem>
        <para>Compiler writers, who want to know what they should
        implement!</para>
      </listitem>

      <listitem>
        <para>Critics, who like to read, emit judgement, and do nothing about
        it</para>
      </listitem>
    </itemizedlist>

    <para>It is assumed, throughout the book, that you have a basic knowledge
    of programming. If you come from a C or Java programming background, you
    should feel at home.</para>

    <para>I hope you'll enjoy the read!<footnote>
        <para>For general information about the ooc programming language,
        <ulink url="http://ooc-lang.org/">visit the official
        website</ulink>.</para>
      </footnote></para>
  </preface>

  <chapter>
    <title>Variables</title>

    <section>
      <title>Types</title>

      <section>
        <title>Syntax</title>

        <section>
          <title>Capitalization</title>

          <para>All types should be in <literal>CamelCase</literal>, all
          variables and functions in <literal>camelCase</literal>. It is a
          significant difference from C and Java, for example. In ooc, an
          integer is declared as <literal>Int</literal>, a boolean as
          <literal>Bool</literal>, and so on.</para>

          <para>The justification for that is consistency. In Java, for
          example, primitive types are in lowercase (<literal>int</literal>,
          <literal>byte</literal>, <literal>short</literal>) and classes are
          in <literal>CamelCase</literal> (<literal>String</literal>,
          <literal>System</literal>). There is some kind of consistency in
          this model, ie. you clearly see what is low-level and high-level.
          However, ooc takes another approach of consistency. Implementation
          details shouldn't interfere with the formatting of the source code.
          Hence, no distinction is made between an <literal>Int</literal> and
          e.g. a <literal>MyClass</literal>, from a user point of view.</para>
        </section>

        <section>
          <title>Declaration</title>

          <para>A variable is declared as in Java/C:</para>

          <programlisting>Float f;
Int i;
String s;</programlisting>

          <para>You can declare several variables on the same line:</para>

          <programlisting>Float x, y, z;</programlisting>

          <caution>
            <para>Unlike C, the array-ness or pointer-ness of the type is
            valid for all the variables declared in the same line.</para>
          </caution>

          <programlisting>Float[256] tab1, tab2, tab3; // declares 3 arrays of 256 floats
Int* p1, p2, p3; // declares 3 pointers to ints</programlisting>
        </section>

        <section>
          <title>Constants</title>

          <para>Constants are declared with the const keyword:</para>

          <programlisting>const Float EPSILON = 0.00001f;</programlisting>

          <para>Constants are usually implemented with
          <literal>#define</literal>s<footnote>
              <para>This may raise a concern: what about name collision? In
              practice, this is almost never a problem with ooc. The generated
              C code is always prefixed with a few underscores '_' and the
              package and source unit name. E.g.
              __my_app_MyUnit_CONSTANT</para>
            </footnote>, so it's really impossible to modify one.</para>
        </section>

        <section>
          <title>Literals &amp; initialization</title>

          <para>ooc supports the same kinds of literal as C:</para>

          <programlisting>Int i = 3;
Short j = -43;
Double golden = 1.6180339887 + 6d; // d suffix is optional
Float = 45.0f - 3; // f suffix is optional
Char c = '3';
Char d = '\n';
String s = "Moi, j'aime p\nas les linebreaks.";</programlisting>

          <para>Underscores in number literals are autorhized and ignored, so
          that you can easily separate groups of digits. Strings can span over
          several lines:</para>

          <programlisting>Int million = 1_000_000_000;
Float x = 3.14159_26535_89793f;
String quote = "Nick the Greek: Just get me a sample.
Tom: No can do.
Nick the Greek: What's that? Some place near Katmandu? Meet me halfway, mate.";</programlisting>
        </section>
      </section>

      <section>
        <title>Types from C</title>

        <section>
          <title>Correspondance with C and Java types</title>

          <table>
            <title>Correspondance tables of types in C, Java, and ooc.</title>

            <tgroup cols="4">
              <thead>
                <row>
                  <entry>C</entry>

                  <entry>Java</entry>

                  <entry>ooc</entry>

                  <entry>Comment</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-</entry>

                  <entry>-</entry>

                  <entry>This</entry>

                  <entry>in a class definition, refers to the current class.
                  Really, really useful to avoid repetition.</entry>
                </row>

                <row>
                  <entry>void*</entry>

                  <entry>Object</entry>

                  <entry>Object</entry>

                  <entry>really just to get rid of the nasty pointer notation.
                  useful while waiting for generics</entry>
                </row>

                <row>
                  <entry>int</entry>

                  <entry>int</entry>

                  <entry>Int</entry>

                  <entry>often the best choice for storing numbers. use Bool
                  to store boolean values.</entry>
                </row>

                <row>
                  <entry>short</entry>

                  <entry>short</entry>

                  <entry>Short</entry>

                  <entry>of little use, really. use it when you have *huge*
                  arrays of numbers and tight memory.</entry>
                </row>

                <row>
                  <entry>char</entry>

                  <entry>char (UTF-16)</entry>

                  <entry>Char</entry>

                  <entry>use it only to store characters. for 8bit numbers,
                  see Octet</entry>
                </row>

                <row>
                  <entry>char*</entry>

                  <entry>String (class)</entry>

                  <entry>String</entry>

                  <entry>fully C-string compatible, unlike C++
                  strings.</entry>
                </row>

                <row>
                  <entry>uint8_t</entry>

                  <entry>byte</entry>

                  <entry>Octet</entry>

                  <entry>again, of little use. may be useful for storing e.g.
                  r, g, b components of a color</entry>
                </row>

                <row>
                  <entry>unsigned int</entry>

                  <entry>-</entry>

                  <entry>UInt</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>float</entry>

                  <entry>float</entry>

                  <entry>Float</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>double</entry>

                  <entry>-</entry>

                  <entry>Double</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long double</entry>

                  <entry>-</entry>

                  <entry>LDouble</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>long</entry>

                  <entry>long</entry>

                  <entry>Long</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long long</entry>

                  <entry>-</entry>

                  <entry>LLong</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>bool</entry>

                  <entry>boolean</entry>

                  <entry>Bool</entry>

                  <entry>uses stdbool's typedefs. You should use
                  <literal>true</literal> and <literal>false</literal> for
                  boolean literals, not 0 and 1.</entry>
                </row>

                <row>
                  <entry>pointer to function</entry>

                  <entry>hahahaha.</entry>

                  <entry>Func</entry>

                  <entry>really points to a function with no arguments
                  returning Int. more function pointer safety should be
                  introduced with generics.</entry>
                </row>

                <row>
                  <entry>size_t</entry>

                  <entry>-</entry>

                  <entry>Size</entry>

                  <entry>the type returned by sizeof. according to the C
                  standard, it should be used to store the 'size' of things,
                  e.g. byte count for memory-related functions (memcpy,
                  memmove)</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section>
          <title>Typedef (aliasing name types)</title>

          <para>Typedefs exist in ooc too. They're used as in C.</para>

          <programlisting>// This example is stupid, because it redefines the String type. It's just to show how typedefs are used.
typedef Char* String;

func main {

  String name = "princesse de slougadij";
  printf("A moins que vous n'epousiez la %s?\n", name);

}</programlisting>

          <para>Don't do funky stuff with typedef: it won't work. E.g.
          <literal>typedef struct { /* etc. */ };</literal> If want a data
          structure, <link linkend="classes">define a class</link>.</para>
        </section>

        <section>
          <title>Capitalization</title>

          <para>If you try to declare something as 'int i', you'll be greeted
          by the compiler with the error message 'Invalid type name int. Types
          must start with an upper-case letter'. In this case, you can sort it
          out by using the ooc-ish 'Int'. But sometimes you just can't, e.g.
          with GLib types, '<literal>gint</literal>',
          '<literal>guint</literal>', etc. The correct handling of these cases
          is to <literal>typedef</literal>' them to something
          capitalized.</para>

          <programlisting>include glib;

typedef guint GUInt;

func main {

  GUInt myPlatformSafeInt = 69;
  gprintf("Now GLib and the ooc compilers are happy.%d\n", myPlatformSafeInt);

}</programlisting>
        </section>

        <section>
          <title>Types that can't be resolved</title>

          <para>Although the C header parser embedded in the ooc compiler
          really tries its best, sometimes (especially with
          <literal>#define</literal>s all over the place), C types aren't
          recognized, and you have compile errors. This can be solved with the
          use of the <literal>ctype</literal> keyword.</para>
        </section>

        <section>
          <title>The 'This' special type.</title>

          <para>In the Java language as in ooc, you have the
          <literal>this</literal> keyword, to refer to the current instance of
          the object we're defining a function of, e.g.:</para>

          <programlisting>class Color {

  Float r, g, b;

  func compare(Float r) {
    if(r != this.r) {
      printf("different !\n");
    }
  }

}</programlisting>

          <para>ooc extends this concept and introduce the
          <literal>This</literal> type, which refers to the type of the class
          we're defining:</para>

          <programlisting>class Vector {

  Float x, y, z;

  // only allow adding with vectors of the same type.
  func add(This v2) {
    x += v2.x;
    y += v2.y;
    z += v2.z;
  }

}</programlisting>
        </section>
      </section>

      <section>
        <title>Covers</title>

        <para>A cover is a set of functions added to a primitive type. For
        example, String is a typedef to char*, and it has a cover
        (<literal>lang.String</literal>), which adds functions
        <literal>length</literal>, <literal>equals</literal>,
        <literal>startsWith</literal>, etc. Covers are low-level constructs
        with a high-level syntax, which makes them very useful in
        performance-critical environments.</para>

        <programlisting>include stdio;

typedef Char* String;

cover String {

  func print {
    puts(this);
  }

}

func main {

  String s = "Hello world!";
  s.print;

}
</programlisting>

        <para>Difference between class and covers will be treated more in
        depth in <link linkend="classes">a next chapter</link>.</para>
      </section>
    </section>

    <section>
      <title>Arrays</title>

      <section>
        <title>Raw C arrays</title>

        <para>Raw C arrays are declared almost as in C, expect the square
        brackets [] are placed somewhere meaningful</para>

        <programlisting>Char[] letters = malloc(26, sizeof(Int));
letter[0] = 'a';

Bool[256] keymap;
Bool escapePressed = keymap[27];

String[] greetings = {"Heya!", "Bien l'bonjour!", "Hallo =)"};

// actually taken from examples/gtk-tests/opengl.ooc
Int[] flags = {
  GDK_GL_RGBA,
  GDK_GL_RED_SIZE, 1,
  GDK_GL_GREEN_SIZE, 1,
  GDK_GL_BLUE_SIZE, 1,
  GDK_GL_DOUBLEBUFFER,
  GDK_GL_NONE,
}</programlisting>

        <para>This kind of arrays are exactly as fast and as unsafe as in C.In
        case you want higher-level arrays, you can wrap them in the Array
        class.</para>
      </section>

      <section>
        <title>The Array class</title>

        <para>The Array class does bound-checking, and allows you to use
        foreach through the array. All those features (classes, foreach) are
        discussed in the next chapters. Here are a few examples of uses of the
        Array class:</para>

        <programlisting>import structs.Array;

func main(Int argc, String[] argv) {

  for(Int arg: new Array(argc, argv)) {
    printf("Got arg '%s'\n", arg);
  }

  Array strings = new Array(4);
  strings.set(0, "Hai furry world!\n"); // okay, 0 &gt;= 0 and 0 &lt; 4
  strings.get(9); // ERROR! index out of bounds (9 &gt; 4).

}</programlisting>

        <para>Array is a fixed-size type. To store a variable number of
        elements, see the <literal>ArrayList</literal> and
        <literal>SparseList</literal> classes.</para>
      </section>
    </section>

    <section>
      <title>Pointers</title>

      <para>Pointers are used in ooc exactly as in C, although they are not as
      welcome. They're used extensively behind the scenes, to implement
      classes, etc, but their use is discouraged when not necessary. A good
      use case for using pointers (instead of a objects, for example) is
      low-level implementation of a speed-critical algorithm. Using pointers
      is to ooc what assembler is to C: something you shouldn't use unless you
      really need it for speed.</para>
    </section>
  </chapter>

  <chapter>
    <title>Functions</title>

    <section>
      <title>Definition</title>

      <section>
        <title>Syntax</title>

        <para>A function is declared with the
        <literal><literal>func</literal></literal> keyword.</para>

        <programlisting>// Empty function with no args that returns nothing
func useless;

func sayHello {
  printf("Hay, world!\n");
}

func saySomethingElse(String message) {
  printf("Dummy says: %s\n", message);
}

func add(Int arg1, Int arg2) -&gt; Int {
  return arg1 + arg2;
}
</programlisting>
      </section>

      <section>
        <title>Same name, different arguments</title>

        <para>In ooc, it's possible to have several functions with the same
        name and different arguments. Which function to call is selected at
        compilation time, based on the number of arguments and their
        types.</para>

        <programlisting>func main {
  dance();
  dance("Too much of heaven/Can bring you underground");
}

func dance {
  dance("Music's got me feeling so free/Celebrate and dance so free/One more time");
}

func dance(String lyrics) {
  printf("DANCE TO THE BEAT! Sing: %s\b", lyrics);
}</programlisting>
      </section>

      <section>
        <title>The main function: entry point</title>

        <para>In ooc, the main function is automatically specified to have the
        return type 'Int'. You can declare it either without arguments, or
        with argc, argv, and envp arguments (optional).</para>

        <programlisting>import structs.Array;

/** envp is optional! it contains the environment variables, and is null-terminated */
func main(Int argc, String[] argv, String[] envp) {

  for(String arg: new Array(argc, argv)) {
    printf("Got argument %s\n", arg);
  }

  Array envs = Array.nullTerminated(envp);
  for(String env: envs) {
    printf("Got environment variable %s\n", env);
  }

}</programlisting>
      </section>
    </section>

    <section>
      <title>Calling functions</title>

      <para>Functions can be called with or without parenthesis, if the
      function has no arguments. Depending on the cases, it can be more
      readable to have explicit parenthesis, or more practical to not have
      them.<caution>
          <para>Calling functions without parenthesis only work with functions
          written in ooc. It won't work with included C functions, because the
          headers files are not parsed for function declarations.<footnote>
              <para>The reason for that is simple. Parsing C headers is a
              nightmare. It's already done for typedefs, for example, and
              there are still cases where it fails (e.g. SDL headers).
              Portable header files are usually filled with #defines, and it
              makes the ooc parser have a hard job understanding them. To fix
              that, we'd have to complete the ooc included C preprocessor,
              which would be very time consuming. For now, you can work around
              the 'unrecognized types' issue with the 'ctype' keyword.</para>
            </footnote></para>
        </caution><programlisting>/*
 * In this example, we use SDL functions to demonstrate that
 * you have to use parenthesis to call C functions.
 * If you were to use the SDL in a real project, it'd be better to use the SDL bindings
 */
include SDL/SDL;

func main {
  init; // Need no parenthesis !
  quit;
}

func init {
  SDL_Init(SDL_INIT_EVERYTHING);
}

func quit {
  SDL_Quit(); // We must use parenthesis, cause it's a C function
}</programlisting></para>

      <para>Calling functions without parenthesis is particularly convenient
      with getters/setters, as we will see later on.</para>
    </section>

    <section>
      <title>Callbacks and pointers</title>

      <section>
        <title>Simple case</title>

        <para>In ooc, functions are almost-first-class-citizens. You can pass
        pointer to functions around easily:</para>

        <programlisting>func main {

  call(@kotokoSpeak);

}

func kotokoSpeak {

  printf("We have a very big problem!\n");

}

func call(Func toCall) {

  toCall();

}</programlisting>

        <para>Since mentioning a function's name without parenthesis is enough
        to call it, the '<literal>@</literal>' prefix is added before the
        function name to indicate that we want a pointer to it, not to execute
        it. This distinction is justified if you consider that a function
        could itself return a pointer to function, thus you can't let the
        compiler guess whether or not to call the function.</para>

        <para>'<literal>@</literal>' doesn't work the same as
        '<literal>&amp;</literal>' in C. For example, the Gtk class as a
        function mainQuit, and it's a common idiom in a gtk program to
        do:</para>

        <programlisting>window.connectNaked("destroy", Gtk.@mainQuit);</programlisting>

        <para>This ensures that Gtk.mainQuit() is called when the window is
        destroyed.</para>
      </section>

      <section>
        <title>Pointer to member functions</title>

        <para>This case is treated in <link linkend="classes">this
        chapter</link>.</para>
      </section>
    </section>

    <section>
      <title>Covers</title>

      <para>A cover is a set of functions added to a primitive type. As an
      example, is here a sample of the <literal>lang.String</literal> cover
      (included in the sdk of the standard ooc distribution):</para>

      <programlisting>typedef Char* String;

cover String {

  func length -&gt; Int {
    return strlen(this);
  }

}</programlisting>

      <para>The definition of String as presented above allows code
      like:</para>

      <programlisting>String word = "anticonstitutionnellement";
printf("the longest french word is %d chars long.\n", word.length);</programlisting>

      <para>Covers can't have constructors, thus they can't be
      instantiated.</para>
    </section>
  </chapter>

  <chapter id="classes">
    <title>Classes</title>

    <section>
      <title>Syntax</title>

      <section>
        <title>Definition</title>

        <para>Classes have member variables and member functions.</para>

        <programlisting>class Dog {

  String name;
  Int age;

  func new; // Empty constructor

  func woof {
    printf("Woof, woof!\n");
  }

}</programlisting>
      </section>

      <section>
        <title>Instanciation</title>

        <para>You can instanciate objects with the new keyword, access their
        member variables and call their member functions pretty much as in
        Java.</para>

        <programlisting>Dog dog = new Dog();</programlisting>

        <para>As with functions, you can instanciate empty constructors
        without parenthesis:</para>

        <programlisting>Dog dog = new Dog;</programlisting>

        <para>The compiler is even smart enough to figure which type to
        instanciate, after a variable declaration or a variable
        assignment:</para>

        <programlisting>Dog dog = new;
Cat cat;
cat = new("meow");</programlisting>

        <para>Not, that, unlike C++, declaring only:</para>

        <programlisting>Bird bird;</programlisting>

        <para>will make bird a dangling pointer. Every object is in fact a
        pointer to a structure. For more details about the underlying
        implementation, see <link linkend="abi">the ABI
        appendix</link>.</para>
      </section>

      <section>
        <title>Static fields</title>

        <para>There can be instance fields and static fields in a class, in
        the Java sense of these words. Example:</para>

        <programlisting>class NastyPattern {

  static Int GLOBAL_SETTING = 42;
  Int koolAid;

  static func create -&gt; This {
    return new This;
  }

  func apply {
    printf("Factories are evil.\n");
  }

}</programlisting>

        <para>Which can then be used like that:</para>

        <programlisting>NastyPattern.GLOBAL_SETTING = 69; // adjust something static first
NastyPattern.koolAid; // ERROR! can't access instance field without an instance

NastyPattern np = NastyPattern.create(); // parenthesis optional, but here for clarity
printf("%d\d", np.koolAid); // we can now access the koolAid field on our instance.</programlisting>
      </section>

      <section>
        <title>Inheritance</title>

        <para>For now, ooc has a simple inheritance model, somewhat like Java.
        To inherit a class, use the <literal>from</literal> keyword. To
        override a function, use the <literal>override</literal> keyword, or
        define a function with the same signature. <literal>override</literal>
        has the advantage of change checking: if the signature of the
        implemented function changes, it'll yield a compile error, instead of
        compiling the wrong version silently (it has the same use as the
        <literal>@Override</literal> annotation in Java).</para>

        <programlisting>class Wheel {

  func roll {
    printf("Quelque-chose ne tourne pas rond.\n");
  }

}

class BetterWheel from Wheel {

  override roll {
    printf("Pierre qui roule n'amasse pas mousse\n");
  }

}

func main {

  Wheel w = new;
  w.roll; // prints "Quelque-chose", etc.

  BetterWheel bw = new;
  bw.roll; // prints "Pierre qui roule", etc.

  Wheel w2 = (Wheel) bw; // cast as in C/Java
  w2.roll; // prints "Pierre qui roule", etc.

}</programlisting>
      </section>

      <section>
        <title>Constructors, super-constructors</title>

        <para>By default, ooc creates an empty constructor with no arguments
        (called default constructor), if there are no constructors in a class.
        As soon as another constructor is defined, the default constructor
        disappears.</para>

        <para>The super-constructor is not explicitly called, but you can call
        a super-constructor explicitly with <literal>super()</literal>, and
        one of your constructors with <literal>this()</literal>.</para>

        <programlisting>import structs.List;
import structs.SparseList;

class Base {

  List list;

  func new {
    list = new SparseList;
  }

}

class Derived from Base {

  Int value;

  func new {
    this(10);
  }

  func new(=value) {
    super(); // call the super-constructor
  }

}</programlisting>
      </section>

      <section>
        <title>Abstract class and functions</title>

        <para>You can declare classes as abstract. They can no longer
        instanciated, and serve as base classes for other. In abstract
        classes, you can define abstract functions, that must be implemented
        by concrete (=non-abstract) child classes. To implement an abstract
        function, use the <literal>implement</literal> keyword. It has the
        same advantage as the <literal>override</literal> keyword.</para>

        <programlisting>import structs.Array;

abstract class Singer {

  abstract func sing;

}

class Hives from Singer {

  implement sing {
    printf("Tick tick tick BOOM!\n");
  }

}

class Spiderbait from Singer {

  implement sing {
    printf("Tonight, I'm going outta my head!\n");
  }

}

func main {

  ArrayList singers = new;
  singers.add(new Hives);
  singers.add(new Spiderbait);

  for(Singer singer: singers) {
    singer.sing;
  }

}</programlisting>
      </section>

      <section>
        <title>Getters, setters</title>

        <para>The ooc programmer likes beautiful code, and has Java's
        getters/setters in horror. ooc's getters/setters are defined like
        that:</para>

        <programlisting>class SecretKeeper {

  String secret;

  func secret {
    // here's our getter
    // do stuff
    // no need to return, it's done for us automatically
  }

  // here's our setter: we leave it empty cause we have nothing special to do before setting.
  func secret(=secret);

}</programlisting>

        <para>It can then be used like that:</para>

        <programlisting>SecretKeeper keeper = new;
keeper.secret("The cake is a lie.");
printf("%s\n", keeper.secret); // actually calls the getter</programlisting>

        <para>The <literal>=field</literal> syntax is particulary useful for
        constructors</para>

        <programlisting>class Vector {

  Float x, y, z;

  func new(=x, =y, =z); // initialization constructor =)

}</programlisting>
      </section>

      <section>
        <title>Pointers to member functions</title>

        <para>Interesting subject, if any. For now, there is a simple
        workaround, which, unfortunately, is only useful if you have only one
        instance of the considered class at run time. It works like
        this</para>

        <programlisting>// declared somewhere
func registerCallback(Func func);

class Handler {

  static This instance;

}</programlisting>
      </section>

      <section>
        <title>Reflection</title>

        <para>ooc has limited support for reflection. For now, it's more of a
        proof of concept, but you can do:</para>

        <programlisting>import structs.Array;

func main {

  printType(new Array);

}

func printType(Object o) {

  printf("We got an object of type %s\n", o.class.name);

}</programlisting>

        <para>In the future, reflection should be completed with fields and
        functions listing, etc.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Statements</title>

    <section>
      <title>loops</title>

      <section>
        <title>classic for</title>

        <para>As can be seen in C99 and Java:</para>

        <programlisting>for(Int i = 0; i &lt; max; i++) {
  // do stuff.
}

// or, more generally:

for(initialization; condition; iteration) {
  // body
}</programlisting>

        <para>Declaration of variables inside the for loop is authorized,
        since ooc is translated to C99.</para>
      </section>

      <section>
        <title>for in ranges</title>

        <section>
          <title>regular</title>

          <para>Somehow reminiscent of scripting languages:</para>

          <programlisting>for(Int i: 0..max) {
  // i goes from 0 to max excluded.
}

// real-world use case
func main(Int argc, String[] argv) {
  
  for(Int i: 1..argc) {
    printf("Got argument '%s'\n", argv[i]);
  }

}</programlisting>
        </section>

        <section>
          <title>reverse</title>

          <para>For terrorist geeks:</para>

          <programlisting>for(Int i: reverse 0..11) {
  printf("%d...\n", i);
}
printf("segmentation fault\n");</programlisting>
        </section>

        <section>
          <title>sparse</title>

          <para>You can specify the stepping</para>

          <programlisting>for(Int i: 2..100, 2) {
  printf("%d, ", i);
}
printf("are multiples of two from 0 to 100.");</programlisting>
        </section>
      </section>

      <section>
        <title>foreach</title>

        <para>Syntax vastly inspired by Java:</para>

        <programlisting>func printAll(List list) {

  for(String str: list) {
    printf("%s, ", str);
  }
  putc('\n');

}

// better than for in ranges
func main(Int argc, String[] argv) {

  for(String arg: new Array(argc, argv)) {
    printf("Got argument '%s'\n", arg);
  }

}</programlisting>

        <para>The foreach is implemented using Iterators. Any class extending
        the abstract class structs.Iterable, which looks like:</para>

        <programlisting>abstract class Iterable {

  abstract func iterator -&gt; Iterator;

}</programlisting>

        <para>And the Iterator class looks like:</para>

        <programlisting>abstract class Iterator {

  abstract func hasNext -&gt; Bool;
  abstract func next -&gt; Object;

}</programlisting>

        <para>The classes in the SDK which extend Iterable are: structs.Array,
        structs.ArrayList, structs.SparseList.</para>
      </section>

      <section>
        <title>while</title>

        <para>As boring as the C/Java one:</para>

        <programlisting>Float x;
while(x &lt; 42.0f) {
  x += (x * x) / 69.0f;
}</programlisting>
      </section>
    </section>

    <section>
      <title>conditionals</title>

      <section>
        <title>if, else</title>

        <para>No surprises:</para>

        <programlisting>if(happy) {
  rejoice;
} else if(moody) {
  listenToMusic;
} else {
  cry;
}</programlisting>
      </section>

      <section>
        <title>switch, case</title>

        <para>No surprises either:</para>

        <programlisting>switch(action) {
  case DIE: die(); break;
  case MOVE: move(); break;
  case LEAVE: leave(); break;
  default: pray();
}</programlisting>
      </section>
    </section>

    <section>
      <title>flow control</title>

      <section>
        <title>break, continue</title>

        <para>Same use as in C/Java:</para>

        <programlisting>while(true) {
  if(shouldExit) {
    break;
  }
}

for(Int i: 0..max) {
  if(shouldSkip) {
    continue;
  }
}</programlisting>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Packages, headers, libraries</title>

    <para>ooc doesn't share C++'s affection for C-style headers. Source files,
    (called 'units'), are organized into folders (called 'packages'), much
    like Java packages without the hassle.<footnote>
        <para>What is the hassle with Java packages? You have to declare a
        class in a file with exactly the same name, and you have to put a a
        package declaration into each .java source file, corresponding exactly
        to your class file. While it is certainly safer, it's also much more
        redundant, and thus ooc has adopted a more relax approach.</para>
      </footnote></para>

    <section>
      <title>ooc packages</title>

      <para>There is no <literal>package</literal> keyword. The package of a
      source unit is relative to the sourcepath. You can import units from
      packages with the <literal>import</literal> keyword. For example, let's
      say we have a Talker unit:</para>

      <programlisting>class Talker {

  func new;

  func drool {
    printf("Mwahahaha\n");
  }

  static func say(String message) {
    printf("Jacadi a dit: %s\n", message);
  }

}</programlisting>

      <para>Let's say the Talker.ooc file is located in
      <filename>io/spoken/Talker.ooc</filename> relative to the sourcepath. If
      we have an <filename>io/spoken/User.ooc</filename> unit, we can use
      Talker like that:</para>

      <programlisting>import Talker;
// or
import io.spoken.Talker;

func blah {
  Talker.say("Blah, blah, blah\n");
}</programlisting>

      <para>You can use the super keyword to refer to a package which is
      higher in the hierarchy, e.g. let's say we have a
      <filename>io/Tube.ooc</filename> unit, we can refer to it in
      <filename>io/spoken/User.ooc</filename> as:</para>

      <programlisting>import io.Tube; // fully qualified name
// or
import super.Tube; // relative name</programlisting>

      <para>The relative form is often preferred, as it facilitate
      refactoring.</para>
    </section>

    <section>
      <title>C headers</title>

      <para>The ooc compiler allows to use every C function and type as-is. It
      recognizes well-formed typedefs without too much macros
      (<literal>#define</literal>s, etc.) in header files.</para>

      <para>You can include C headers with the 'include' keyword.</para>

      <programlisting>include SDL/SDL; // equivalent of #include &lt;SDL/SDL.h&gt;</programlisting>

      <para>For local includes, prefix the path with
      '<literal>@</literal>':</para>

      <programlisting>include @myheader; // equivalent of #include "myheader.h"</programlisting>

      <para>Although including a local header is seldom necessary in ooc,
      since import takes care of all the local imports very well.</para>

      <para>If the ooc compiler fails to parse type definitions in a C header,
      and you use them, you can get 'Can't resolve type &lt;type&gt;' compile
      errors. To work around the problem, use the <literal>ctype</literal>
      keyword. It simply instructs the ooc compiler that the type is typedef'd
      somewhere in a header, and that it shouldn't worry about it.</para>

      <programlisting>include SDL/SDL; // the SDL headers are full of defines

ctype SDL_Event; // the ooc compiler can't parse this type so we reference it

func wait {

  SDL_Event event; // we can now use it
  SDL_WaitEvents(&amp;event);

}</programlisting>
    </section>

    <section>
      <title>Automagic library management</title>

      <para>The <literal>use</literal> keyword allows automagic management of
      includes and linking. Example:</para>

      <programlisting>use glut;

func main {

  // use glut functions

}</programlisting>

      <para>The 'use glut' statement above will include the glut headers, link
      with the glut library (<literal>-lglut</literal>), and it depends on
      'use glu' and 'use gl', which will in turn link with
      <literal>-lGLU</literal> and <literal>-lGL</literal> and include
      GL/GL.h, etc.</para>

      <para>The sweet thing, is that it links with the right library,
      depending on the platform! E.g. 'use gc', which is implicit in every ooc
      class, links with a static version of the gc library for your platform.
      'use gl' links with <literal>-lopengl32</literal> on Windows, and so
      on.</para>

      <para>Even for libraries not handled specially ooc, you can link to them
      with 'use lib', it will link with '-llib'.</para>
    </section>
  </chapter>

  <appendix id="abi">
    <title>ABI (Application Binary Interface)</title>

    <para>The ooc ABI is designed to be simple and straight-forward. Also,
    there is an official ABI so that different implementations be
    compatible.<footnote>
        <para>When I say <emphasis>different implementations</emphasis>, I
        particularly think about <ulink
        url="http://github.com/amoswenger/rock">rock, the all-new attempt to
        write an ooc compiler in the ooc language</ulink>. At the time of this
        writing, it's very young: time has been spent developing ooc's
        features that could be useful for rock, rather than rock itself. As
        always, contributors are very welcome!</para>
      </footnote></para>

    <para>Note that the ooc specification is still under heavy development, so
    it means that the ABI can change significantly from a "dot version" to
    another.</para>

    <section>
      <title>Types</title>

      <para>All basic types are typedefs to C standard types:</para>

      <programlisting>typedef char* String;
typedef void* Object;
typedef bool Bool;
typedef char Char;
typedef int Int;
typedef unsigned int UInt;
typedef float Float;
typedef double Double;
typedef long double LDouble;
typedef short Short;
typedef long Long;
typedef long long LLong;
typedef void Void;
typedef int (*Func)();
typedef size_t Size;
typedef uint8_t Octet;</programlisting>
    </section>

    <section>
      <title>Classes</title>

      <section>
        <title>Structs in memory</title>

        <para>Classes are implemented with two C structs : the 'meta-class'
        structure, and the 'class structure'.</para>

        <para>The 'meta-class structure' exists in one copy in memory for each
        defined class. It contains all the information which is shared between
        instances of a class, such as function pointers to the right
        implementation of functions.</para>

        <para>The 'class structure' is allocated for each instance of a class.
        It contains first a pointer (void*) to the meta-class structure, and
        then a list of fields.</para>
      </section>

      <section>
        <title>Order of fields in structs</title>

        <para>Since a child class (a class that inherits from a base class)
        only add member variables and functions, its structs begin with
        exactly the same field order as its parent, and then its own member
        variables/functions are added. This allows seamless C casts, which are
        basically free from a performance point of view.</para>
      </section>

      <section>
        <title>Functions and constructors</title>

        <para>Member functions are pointer to functions in the 'meta-class
        structure'. They are assigned to in constructors. Constructors aren't
        listed in the meta-class structure, nor are the rest of static
        functions.</para>
      </section>

      <section>
        <title>Static fields</title>

        <para>Static fields must be implemented as externally-scoped variable
        for non-const fields, and with <literal>#define</literal>s for const
        fields.</para>
      </section>
    </section>

    <section>
      <title>Name mangling</title>

      <para>Name mangling is applied to functions and static members of
      classes. The followed scheme is the following:</para>

      <itemizedlist>
        <listitem>
          <para>Off-class Function</para>

          <itemizedlist>
            <listitem>
              <para>Name: my_package__functionName</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Off-class Variable</para>

          <itemizedlist>
            <listitem>
              <para>Name: my_package__variableName</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Member Variable</para>

          <itemizedlist>
            <listitem>
              <para>Struct field name: variableName (no mangling)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Static Member Variable</para>

          <itemizedlist>
            <listitem>
              <para>Name:
              my_package_ClassName_functionName_ArgType1_ArgType2_ArgType3</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Member Function</para>

          <itemizedlist>
            <listitem>
              <para>Name:
              __my_package_ClassName_functionName_ArgType1_ArgType2_ArgType3</para>
            </listitem>

            <listitem>
              <para>Struct field name:
              __functionName_ArgType1_ArgType2_ArgType3</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Static Member Function</para>

          <itemizedlist>
            <listitem>
              <para>Name: see Member Function.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>ArgType mangling is the name of the type, appended with "__star"
      and "__array" as many times as necessary to represent the pointer level
      of the type.</para>
    </section>
  </appendix>

  <appendix>
    <title>FAQ (Frequently Asked Questions)</title>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">All of this is nice and dandy, but I just
        can't wait to try it! Tell me where I can download
        it!</emphasis></para>
      </listitem>

      <listitem>
        <para><ulink url="http://ooc-lang.org/">Download page on
        ooc-lang</ulink></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Why is it called ooc?</emphasis></para>
      </listitem>

      <listitem>
        <para>It stands for 'object oriented C'</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Why are there no C-like structs in
        ooc?</emphasis></para>
      </listitem>

      <listitem>
        <para>A class without any functions translates exactly to a struct. It
        is just as cheap/fast, hence, there is apparently no need for a struct
        keyword in ooc.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Why don't all arrays store their length as
        their first size_t bits?</emphasis></para>
      </listitem>

      <listitem>
        <para>Use the Array class for that. It also provides bound checking.
        For the rest, Int[], etc. are still raw C arrays, for compatibility
        with C functions.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">What's wrong with C++? Why aren't you
        using it?</emphasis></para>
      </listitem>

      <listitem>
        <para>See <ulink url="http://yosefk.com/c++fqa/">The C++ Frequently
        Questioned Answers, by Yossi Kreinin</ulink></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">What's wrong with Java/C#? Why aren't you
        using them?</emphasis></para>
      </listitem>

      <listitem>
        <para>Java and C# suffer from the drawbacks of general-purpose
        languages running on Virtual Machines. Namely, they tend to be
        bloated, to have heavy runtime libraries, and to be significantly less
        performant than compiled languages in certain situations. However,
        it's true that with JIT (Just-In-Time) technology, a VM language can
        run almost as fast as a compiled language, in certain situations. See
        the <ulink url="http://kano.net/javabench/">The Java is Faster than
        C++ and C++ Sucks Unbiased Benchmark</ulink>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">What's wrong with Vala? Why aren't you
        using it?</emphasis></para>
      </listitem>

      <listitem>
        <para>Vala is a language with the same spirit/mission as ooc. It looks
        very good, but it's deeply tied to the GLib architecture. ooc tries to
        base itself only on the C standard library. Vala is more adapted to
        gtk/gnome development.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">What's wrong with
        Python/Ruby/D?</emphasis></para>
      </listitem>

      <listitem>
        <para>Not much. These are all excellent languages and have quality
        implementations. They're good at what they're used for. ooc is not in
        direct competition with these languages. D is a sad case of very good
        ideas doomed by half-openness, diverging and lagging free software
        implementations, stalling between 1.0 and 2.0, etc.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">I think ooc is too
        high-level.</emphasis></para>
      </listitem>

      <listitem>
        <para>For all your unconfessed low-level "let's get dirty, boys"
        needs, I recommend the awesome <ulink url="http://nasm.us/">Netwide
        Assembler</ulink>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">I still think your language sucks, and my
        language rocks</emphasis></para>
      </listitem>

      <listitem>
        <para>And you have your reasons. I'm developing ooc in the hope that
        it will be useful and that some people like it. If you don't, well,
        too bad, I'm sure one of the aforementioned languages will satisfy
        you.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Which other languages would you recommend
        as interesting?</emphasis></para>
      </listitem>

      <listitem>
        <para>I have a particular fondness for the <ulink
        url="http://www.iolanguage.com/">Io programming language</ulink>. On
        the JVM, <ulink url="http://www.scala-lang.org/">Scala</ulink> is
        probably one of the best languages around.</para>
      </listitem>
    </itemizedlist>
  </appendix>

  <appendix>
    <title>How to contribute</title>

    <para>If you've read this guide this far, you're already part of ooc's
    history!</para>

    <para>If you want to help further, here are some things you can do:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">Talk about ooc</emphasis> to your
        friends/colleagues/soulmate/CEO</para>
      </listitem>

      <listitem>
        <para>Blog about it / <emphasis role="bold">Write an article about
        it</emphasis> on your website / in your magazine</para>
      </listitem>

      <listitem>
        <para><ulink url="http://bugs.launchpad.net/ooc-language">Report
        bugs/suggestions on launchpad.</ulink></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Send patches</emphasis> to fix bugs/add
        features (developer access to the git repository will be given out
        pretty easily)</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Write documentation</emphasis>: tutorials,
        etc. And send them for publication to the official website</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Help testing ooc on various
        platforms.</emphasis> The main development happens on Linux, but we
        want to be as portable as possible. Windows/OSX/*BSD/Haiku users, to
        your test benches!</para>
      </listitem>

      <listitem>
        <para>Write a program/game/demo in ooc: show the world that you can
        use OpenGL/SDL/GTK/etc. libraries with ooc</para>
      </listitem>

      <listitem>
        <para><ulink url="http://github.com/amoswenger/rock">Contribute to
        rock</ulink>, the 'ooc compiler written in ooc' effort.</para>
      </listitem>

      <listitem>
        <para>Send a kind e-mail to <ulink type=""
        url="mailto:amoswenger@gmail.com">amoswenger@gmail.com</ulink> to let
        know you like/use ooc!</para>
      </listitem>
    </itemizedlist>
  </appendix>

  <appendix>
    <title>Links</title>

    <para><ulink url="http://ooc-lang.org/">the official ooc
    website</ulink></para>

    <para><ulink url="http://github.com/amoswenger/ooc">the source git
    repository on GitHub</ulink></para>

    <para><ulink url="http://live.gnome.org/Vala">the Vala programming
    language: same spirit but tied on GLib (excellent for gtk/gnome
    apps)</ulink></para>
  </appendix>

  <appendix id="fdl">
    &license;
  </appendix>
</book>
